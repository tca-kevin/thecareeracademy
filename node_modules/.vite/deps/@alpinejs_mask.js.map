{
  "version": 3,
  "sources": ["../../@alpinejs/mask/dist/module.esm.js"],
  "sourcesContent": ["// packages/mask/src/index.js\nfunction src_default(Alpine) {\n  Alpine.directive(\"mask\", (el, { value, expression }, { effect, evaluateLater, cleanup }) => {\n    let templateFn = () => expression;\n    let lastInputValue = \"\";\n    queueMicrotask(() => {\n      if ([\"function\", \"dynamic\"].includes(value)) {\n        let evaluator = evaluateLater(expression);\n        effect(() => {\n          templateFn = (input) => {\n            let result;\n            Alpine.dontAutoEvaluateFunctions(() => {\n              evaluator((value2) => {\n                result = typeof value2 === \"function\" ? value2(input) : value2;\n              }, { scope: {\n                // These are \"magics\" we'll make available to the x-mask:function:\n                \"$input\": input,\n                \"$money\": formatMoney.bind({ el })\n              } });\n            });\n            return result;\n          };\n          processInputValue(el, false);\n        });\n      } else {\n        processInputValue(el, false);\n      }\n      if (el._x_model)\n        el._x_model.set(el.value);\n    });\n    const controller = new AbortController();\n    cleanup(() => {\n      controller.abort();\n    });\n    el.addEventListener(\"input\", () => processInputValue(el), {\n      signal: controller.signal,\n      // Setting this as a capture phase listener to ensure it runs\n      // before wire:model or x-model added as a latent binding...\n      capture: true\n    });\n    el.addEventListener(\"blur\", () => processInputValue(el, false), { signal: controller.signal });\n    function processInputValue(el2, shouldRestoreCursor = true) {\n      let input = el2.value;\n      let template = templateFn(input);\n      if (!template || template === \"false\")\n        return false;\n      if (lastInputValue.length - el2.value.length === 1) {\n        return lastInputValue = el2.value;\n      }\n      let setInput = () => {\n        lastInputValue = el2.value = formatInput(input, template);\n      };\n      if (shouldRestoreCursor) {\n        restoreCursorPosition(el2, template, () => {\n          setInput();\n        });\n      } else {\n        setInput();\n      }\n    }\n    function formatInput(input, template) {\n      if (input === \"\")\n        return \"\";\n      let strippedDownInput = stripDown(template, input);\n      let rebuiltInput = buildUp(template, strippedDownInput);\n      return rebuiltInput;\n    }\n  }).before(\"model\");\n}\nfunction restoreCursorPosition(el, template, callback) {\n  let cursorPosition = el.selectionStart;\n  let unformattedValue = el.value;\n  callback();\n  let beforeLeftOfCursorBeforeFormatting = unformattedValue.slice(0, cursorPosition);\n  let newPosition = buildUp(\n    template,\n    stripDown(\n      template,\n      beforeLeftOfCursorBeforeFormatting\n    )\n  ).length;\n  el.setSelectionRange(newPosition, newPosition);\n}\nfunction stripDown(template, input) {\n  let inputToBeStripped = input;\n  let output = \"\";\n  let regexes = {\n    \"9\": /[0-9]/,\n    \"a\": /[a-zA-Z]/,\n    \"*\": /[a-zA-Z0-9]/\n  };\n  let wildcardTemplate = \"\";\n  for (let i = 0; i < template.length; i++) {\n    if ([\"9\", \"a\", \"*\"].includes(template[i])) {\n      wildcardTemplate += template[i];\n      continue;\n    }\n    for (let j = 0; j < inputToBeStripped.length; j++) {\n      if (inputToBeStripped[j] === template[i]) {\n        inputToBeStripped = inputToBeStripped.slice(0, j) + inputToBeStripped.slice(j + 1);\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < wildcardTemplate.length; i++) {\n    let found = false;\n    for (let j = 0; j < inputToBeStripped.length; j++) {\n      if (regexes[wildcardTemplate[i]].test(inputToBeStripped[j])) {\n        output += inputToBeStripped[j];\n        inputToBeStripped = inputToBeStripped.slice(0, j) + inputToBeStripped.slice(j + 1);\n        found = true;\n        break;\n      }\n    }\n    if (!found)\n      break;\n  }\n  return output;\n}\nfunction buildUp(template, input) {\n  let clean = Array.from(input);\n  let output = \"\";\n  for (let i = 0; i < template.length; i++) {\n    if (![\"9\", \"a\", \"*\"].includes(template[i])) {\n      output += template[i];\n      continue;\n    }\n    if (clean.length === 0)\n      break;\n    output += clean.shift();\n  }\n  return output;\n}\nfunction formatMoney(input, delimiter = \".\", thousands, precision = 2) {\n  if (input === \"-\")\n    return \"-\";\n  if (/^\\D+$/.test(input))\n    return \"9\";\n  if (thousands === null || thousands === void 0) {\n    thousands = delimiter === \",\" ? \".\" : \",\";\n  }\n  let addThousands = (input2, thousands2) => {\n    let output = \"\";\n    let counter = 0;\n    for (let i = input2.length - 1; i >= 0; i--) {\n      if (input2[i] === thousands2)\n        continue;\n      if (counter === 3) {\n        output = input2[i] + thousands2 + output;\n        counter = 0;\n      } else {\n        output = input2[i] + output;\n      }\n      counter++;\n    }\n    return output;\n  };\n  let minus = input.startsWith(\"-\") ? \"-\" : \"\";\n  let strippedInput = input.replaceAll(new RegExp(`[^0-9\\\\${delimiter}]`, \"g\"), \"\");\n  let template = Array.from({ length: strippedInput.split(delimiter)[0].length }).fill(\"9\").join(\"\");\n  template = `${minus}${addThousands(template, thousands)}`;\n  if (precision > 0 && input.includes(delimiter))\n    template += `${delimiter}` + \"9\".repeat(precision);\n  queueMicrotask(() => {\n    if (this.el.value.endsWith(delimiter))\n      return;\n    if (this.el.value[this.el.selectionStart - 1] === delimiter) {\n      this.el.setSelectionRange(this.el.selectionStart - 1, this.el.selectionStart - 1);\n    }\n  });\n  return template;\n}\n\n// packages/mask/builds/module.js\nvar module_default = src_default;\nexport {\n  module_default as default,\n  src_default as mask,\n  stripDown\n};\n"],
  "mappings": "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",
  "names": []
}
