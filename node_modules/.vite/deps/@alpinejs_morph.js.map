{
  "version": 3,
  "sources": ["../../@alpinejs/morph/dist/module.esm.js"],
  "sourcesContent": ["// packages/morph/src/morph.js\nfunction morph(from, toHtml, options) {\n  monkeyPatchDomSetAttributeToAllowAtSymbols();\n  let fromEl;\n  let toEl;\n  let key, lookahead, updating, updated, removing, removed, adding, added;\n  function assignOptions(options2 = {}) {\n    let defaultGetKey = (el) => el.getAttribute(\"key\");\n    let noop = () => {\n    };\n    updating = options2.updating || noop;\n    updated = options2.updated || noop;\n    removing = options2.removing || noop;\n    removed = options2.removed || noop;\n    adding = options2.adding || noop;\n    added = options2.added || noop;\n    key = options2.key || defaultGetKey;\n    lookahead = options2.lookahead || false;\n  }\n  function patch(from2, to) {\n    if (differentElementNamesTypesOrKeys(from2, to)) {\n      return swapElements(from2, to);\n    }\n    let updateChildrenOnly = false;\n    if (shouldSkip(updating, from2, to, () => updateChildrenOnly = true))\n      return;\n    if (from2.nodeType === 1 && window.Alpine) {\n      window.Alpine.cloneNode(from2, to);\n      if (from2._x_teleport && to._x_teleport) {\n        patch(from2._x_teleport, to._x_teleport);\n      }\n    }\n    if (textOrComment(to)) {\n      patchNodeValue(from2, to);\n      updated(from2, to);\n      return;\n    }\n    if (!updateChildrenOnly) {\n      patchAttributes(from2, to);\n    }\n    updated(from2, to);\n    patchChildren(from2, to);\n  }\n  function differentElementNamesTypesOrKeys(from2, to) {\n    return from2.nodeType != to.nodeType || from2.nodeName != to.nodeName || getKey(from2) != getKey(to);\n  }\n  function swapElements(from2, to) {\n    if (shouldSkip(removing, from2))\n      return;\n    let toCloned = to.cloneNode(true);\n    if (shouldSkip(adding, toCloned))\n      return;\n    from2.replaceWith(toCloned);\n    removed(from2);\n    added(toCloned);\n  }\n  function patchNodeValue(from2, to) {\n    let value = to.nodeValue;\n    if (from2.nodeValue !== value) {\n      from2.nodeValue = value;\n    }\n  }\n  function patchAttributes(from2, to) {\n    if (from2._x_transitioning)\n      return;\n    if (from2._x_isShown && !to._x_isShown) {\n      return;\n    }\n    if (!from2._x_isShown && to._x_isShown) {\n      return;\n    }\n    let domAttributes = Array.from(from2.attributes);\n    let toAttributes = Array.from(to.attributes);\n    for (let i = domAttributes.length - 1; i >= 0; i--) {\n      let name = domAttributes[i].name;\n      if (!to.hasAttribute(name)) {\n        from2.removeAttribute(name);\n      }\n    }\n    for (let i = toAttributes.length - 1; i >= 0; i--) {\n      let name = toAttributes[i].name;\n      let value = toAttributes[i].value;\n      if (from2.getAttribute(name) !== value) {\n        from2.setAttribute(name, value);\n      }\n    }\n  }\n  function patchChildren(from2, to) {\n    let fromKeys = keyToMap(from2.children);\n    let fromKeyHoldovers = {};\n    let currentTo = getFirstNode(to);\n    let currentFrom = getFirstNode(from2);\n    while (currentTo) {\n      seedingMatchingId(currentTo, currentFrom);\n      let toKey = getKey(currentTo);\n      let fromKey = getKey(currentFrom);\n      if (!currentFrom) {\n        if (toKey && fromKeyHoldovers[toKey]) {\n          let holdover = fromKeyHoldovers[toKey];\n          from2.appendChild(holdover);\n          currentFrom = holdover;\n          fromKey = getKey(currentFrom);\n        } else {\n          if (!shouldSkip(adding, currentTo)) {\n            let clone = currentTo.cloneNode(true);\n            from2.appendChild(clone);\n            added(clone);\n          }\n          currentTo = getNextSibling(to, currentTo);\n          continue;\n        }\n      }\n      let isIf = (node) => node && node.nodeType === 8 && node.textContent === \"[if BLOCK]><![endif]\";\n      let isEnd = (node) => node && node.nodeType === 8 && node.textContent === \"[if ENDBLOCK]><![endif]\";\n      if (isIf(currentTo) && isIf(currentFrom)) {\n        let nestedIfCount = 0;\n        let fromBlockStart = currentFrom;\n        while (currentFrom) {\n          let next = getNextSibling(from2, currentFrom);\n          if (isIf(next)) {\n            nestedIfCount++;\n          } else if (isEnd(next) && nestedIfCount > 0) {\n            nestedIfCount--;\n          } else if (isEnd(next) && nestedIfCount === 0) {\n            currentFrom = next;\n            break;\n          }\n          currentFrom = next;\n        }\n        let fromBlockEnd = currentFrom;\n        nestedIfCount = 0;\n        let toBlockStart = currentTo;\n        while (currentTo) {\n          let next = getNextSibling(to, currentTo);\n          if (isIf(next)) {\n            nestedIfCount++;\n          } else if (isEnd(next) && nestedIfCount > 0) {\n            nestedIfCount--;\n          } else if (isEnd(next) && nestedIfCount === 0) {\n            currentTo = next;\n            break;\n          }\n          currentTo = next;\n        }\n        let toBlockEnd = currentTo;\n        let fromBlock = new Block(fromBlockStart, fromBlockEnd);\n        let toBlock = new Block(toBlockStart, toBlockEnd);\n        patchChildren(fromBlock, toBlock);\n        continue;\n      }\n      if (currentFrom.nodeType === 1 && lookahead && !currentFrom.isEqualNode(currentTo)) {\n        let nextToElementSibling = getNextSibling(to, currentTo);\n        let found = false;\n        while (!found && nextToElementSibling) {\n          if (nextToElementSibling.nodeType === 1 && currentFrom.isEqualNode(nextToElementSibling)) {\n            found = true;\n            currentFrom = addNodeBefore(from2, currentTo, currentFrom);\n            fromKey = getKey(currentFrom);\n          }\n          nextToElementSibling = getNextSibling(to, nextToElementSibling);\n        }\n      }\n      if (toKey !== fromKey) {\n        if (!toKey && fromKey) {\n          fromKeyHoldovers[fromKey] = currentFrom;\n          currentFrom = addNodeBefore(from2, currentTo, currentFrom);\n          fromKeyHoldovers[fromKey].remove();\n          currentFrom = getNextSibling(from2, currentFrom);\n          currentTo = getNextSibling(to, currentTo);\n          continue;\n        }\n        if (toKey && !fromKey) {\n          if (fromKeys[toKey]) {\n            currentFrom.replaceWith(fromKeys[toKey]);\n            currentFrom = fromKeys[toKey];\n            fromKey = getKey(currentFrom);\n          }\n        }\n        if (toKey && fromKey) {\n          let fromKeyNode = fromKeys[toKey];\n          if (fromKeyNode) {\n            fromKeyHoldovers[fromKey] = currentFrom;\n            currentFrom.replaceWith(fromKeyNode);\n            currentFrom = fromKeyNode;\n            fromKey = getKey(currentFrom);\n          } else {\n            fromKeyHoldovers[fromKey] = currentFrom;\n            currentFrom = addNodeBefore(from2, currentTo, currentFrom);\n            fromKeyHoldovers[fromKey].remove();\n            currentFrom = getNextSibling(from2, currentFrom);\n            currentTo = getNextSibling(to, currentTo);\n            continue;\n          }\n        }\n      }\n      let currentFromNext = currentFrom && getNextSibling(from2, currentFrom);\n      patch(currentFrom, currentTo);\n      currentTo = currentTo && getNextSibling(to, currentTo);\n      currentFrom = currentFromNext;\n    }\n    let removals = [];\n    while (currentFrom) {\n      if (!shouldSkip(removing, currentFrom))\n        removals.push(currentFrom);\n      currentFrom = getNextSibling(from2, currentFrom);\n    }\n    while (removals.length) {\n      let domForRemoval = removals.shift();\n      domForRemoval.remove();\n      removed(domForRemoval);\n    }\n  }\n  function getKey(el) {\n    return el && el.nodeType === 1 && key(el);\n  }\n  function keyToMap(els) {\n    let map = {};\n    for (let el of els) {\n      let theKey = getKey(el);\n      if (theKey) {\n        map[theKey] = el;\n      }\n    }\n    return map;\n  }\n  function addNodeBefore(parent, node, beforeMe) {\n    if (!shouldSkip(adding, node)) {\n      let clone = node.cloneNode(true);\n      parent.insertBefore(clone, beforeMe);\n      added(clone);\n      return clone;\n    }\n    return node;\n  }\n  assignOptions(options);\n  fromEl = from;\n  toEl = typeof toHtml === \"string\" ? createElement(toHtml) : toHtml;\n  if (window.Alpine && window.Alpine.closestDataStack && !from._x_dataStack) {\n    toEl._x_dataStack = window.Alpine.closestDataStack(from);\n    toEl._x_dataStack && window.Alpine.cloneNode(from, toEl);\n  }\n  patch(from, toEl);\n  fromEl = void 0;\n  toEl = void 0;\n  return from;\n}\nmorph.step = () => {\n};\nmorph.log = () => {\n};\nfunction shouldSkip(hook, ...args) {\n  let skip = false;\n  hook(...args, () => skip = true);\n  return skip;\n}\nvar patched = false;\nfunction createElement(html) {\n  const template = document.createElement(\"template\");\n  template.innerHTML = html;\n  return template.content.firstElementChild;\n}\nfunction textOrComment(el) {\n  return el.nodeType === 3 || el.nodeType === 8;\n}\nvar Block = class {\n  constructor(start, end) {\n    this.startComment = start;\n    this.endComment = end;\n  }\n  get children() {\n    let children = [];\n    let currentNode = this.startComment.nextSibling;\n    while (currentNode && currentNode !== this.endComment) {\n      children.push(currentNode);\n      currentNode = currentNode.nextSibling;\n    }\n    return children;\n  }\n  appendChild(child) {\n    this.endComment.before(child);\n  }\n  get firstChild() {\n    let first = this.startComment.nextSibling;\n    if (first === this.endComment)\n      return;\n    return first;\n  }\n  nextNode(reference) {\n    let next = reference.nextSibling;\n    if (next === this.endComment)\n      return;\n    return next;\n  }\n  insertBefore(newNode, reference) {\n    reference.before(newNode);\n    return newNode;\n  }\n};\nfunction getFirstNode(parent) {\n  return parent.firstChild;\n}\nfunction getNextSibling(parent, reference) {\n  let next;\n  if (parent instanceof Block) {\n    next = parent.nextNode(reference);\n  } else {\n    next = reference.nextSibling;\n  }\n  return next;\n}\nfunction monkeyPatchDomSetAttributeToAllowAtSymbols() {\n  if (patched)\n    return;\n  patched = true;\n  let original = Element.prototype.setAttribute;\n  let hostDiv = document.createElement(\"div\");\n  Element.prototype.setAttribute = function newSetAttribute(name, value) {\n    if (!name.includes(\"@\")) {\n      return original.call(this, name, value);\n    }\n    hostDiv.innerHTML = `<span ${name}=\"${value}\"></span>`;\n    let attr = hostDiv.firstElementChild.getAttributeNode(name);\n    hostDiv.firstElementChild.removeAttributeNode(attr);\n    this.setAttributeNode(attr);\n  };\n}\nfunction seedingMatchingId(to, from) {\n  let fromId = from && from._x_bindings && from._x_bindings.id;\n  if (!fromId)\n    return;\n  if (!to.setAttribute)\n    return;\n  to.setAttribute(\"id\", fromId);\n  to.id = fromId;\n}\n\n// packages/morph/src/index.js\nfunction src_default(Alpine) {\n  Alpine.morph = morph;\n}\n\n// packages/morph/builds/module.js\nvar module_default = src_default;\nexport {\n  module_default as default,\n  src_default as morph\n};\n"],
  "mappings": "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",
  "names": []
}
